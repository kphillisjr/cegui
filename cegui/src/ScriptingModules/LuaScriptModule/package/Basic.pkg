/************************************************************************
    rename the default template basic types to be shorter :)
*************************************************************************/
$renaming Vector2_float @ Vector2
$renaming Vector3_float @ Vector3
$renaming Size_float @ Size


// Possible actions when loading an XML resource that already exists.
enum XMLResourceExistsAction
{
    XREA_RETURN,
    XREA_REPLACE,
    XREA_THROW
};

/***********************************************************************
    Vector2
***********************************************************************/
class Vector2
{
    TOLUA_TEMPLATE_BIND(T, float)

    // rename 'd_x' and 'd_y' to just 'x' and 'y'
    T d_x @ x;
    T d_y @ y;

    Vector2<T> operator+ (const Vector2<T>& vec) const;
    Vector2<T> operator- (const Vector2<T>& vec) const;
    Vector2<T> operator* (const Vector2<T>& vec) const;
    bool operator== (const Vector2<T>& vec) const;

    Vector2();
    Vector2(T x, T y);
};

/***********************************************************************
    Vector3
***********************************************************************/
class Vector3
{
    TOLUA_TEMPLATE_BIND(T, float)

    // rename 'd_x', 'd_y' and 'd_z' to just 'x', 'y' and 'z'
    T d_x @ x;
    T d_y @ y;
    T d_z @ z;

    bool operator== (const Vector3<T>& vec) const;

    Vector3();
    Vector3(T x, T y, T z);
};

/***********************************************************************
	Size
***********************************************************************/
class Size
{
    TOLUA_TEMPLATE_BIND(T, float)

	// rename 'd_width' and 'd_height' to just 'width' and 'height'
	T d_width @ width;
	T d_height @ height;

	bool operator== (const Size<T>& sz) const;

	Size();
	Size(T w, T h);
};



/***********************************************************************
	Rect
***********************************************************************/
class Rect
{
	// remove member variable 'd_' prefix
	float d_top @ top;
	float d_bottom @ bottom;
	float d_left @ left;
	float d_right @ right;

	Vector2<float> getPosition() const;
	float getWidth() const;
	float getHeight() const;
	Size<float> getSize() const;

	Rect getIntersection(const Rect& rect) const;
	bool isPointInRect(const Vector2<float>& p) const;

	void setPosition(const Vector2<float>& p);
	void setWidth(float w);
	void setHeight(float h);
	void setSize(const Size<float>& sz);

	Rect& offset(const Vector2<float>& p);
	Rect& constrainSizeMax(const Size<float>& sz);
	Rect& constrainSizeMin(const Size<float>& sz);
	Rect& constrainSize(const Size<float>& min, const Size<float>& max);

	bool operator== (const Rect& r) const;

	Rect();
	Rect(float l, float t, float r, float b);
};

class Quaternion
{
    float d_w @ w;
    float d_x @ x;
    float d_y @ y;
    float d_z @ z;

    static const Quaternion ZERO;
    static const Quaternion IDENTITY;

    static Quaternion eulerAnglesRadians(float x, float y, float z);
    static Quaternion eulerAnglesDegrees(float x, float y, float z);
    static Quaternion axisAngleRadians(const Vector3<float>& axis, float rotation);
    static Quaternion axisAngleDegrees(const Vector3<float>& axis, float rotation);

    static Quaternion slerp(const Quaternion& left, const Quaternion& right, float position, bool shortestPath = false);

    Quaternion(float w = 1.0, float x = 0.0, float y = 0.0, float z = 0.0);
    Quaternion(const Quaternion& v);
    //Quaternion& operator= (const Quaternion& v);

    bool operator== (const Quaternion& v) const;
    //bool operator!= (const Quaternion& v) const;
    Quaternion operator- () const;
    Quaternion operator+ (const Quaternion& v) const;
    Quaternion operator* (const Quaternion& v) const;
    Quaternion operator* (float v) const;
    //inline friend Quaternion operator * (float v, const Quaternion& q);

    float dot(const Quaternion& v) const;
    float length() const;
    float normalise();
};


/***********************************************************************
	Colour
***********************************************************************/
class Colour
{
	float getAlpha() const;
	float getRed() const;
	float getGreen() const;
	float getBlue() const;
	float getHue() const;
	float getSaturation() const;
	float getLumination() const;

	void set(float r, float g, float b, float a);
	void setAlpha(float a);
	void setRed(float r);
	void setGreen(float g);
	void setBlue(float b);
	void setRGB(float r, float g, float b);
	void setHSL(float hue, float saturation, float luminance, float alpha=1);

	Colour operator+ (const Colour& c) const;
	Colour operator- (const Colour& c) const;
	//Colour operator* (const Colour& c) const; // gives a warning about argb_t to Colour conversion
	bool operator== (const Colour& c) const;

	Colour();
	Colour(float r, float g, float b, float a);
};



/***********************************************************************
	ColourRect
***********************************************************************/
class ColourRect
{
	Colour d_top_left @ top_left;
	Colour d_top_right @ top_right;
	Colour d_bottom_left @ bottom_left;
	Colour d_bottom_right @ bottom_right;

	void	setAlpha(float alpha);
	void	setTopAlpha(float alpha);
	void	setBottomAlpha(float alpha);
	void	setLeftAlpha(float alpha);
	void	setRightAlpha(float alpha);
	void	modulateAlpha(float alpha);

	void	setColours(const Colour& col);

	bool	isMonochromatic() const;

	ColourRect getSubRectangle( float left, float right, float top, float bottom ) const;
	Colour getColourAtPoint( float x, float y ) const;

	//ColourRect& operator*= (const ColourRect& other); // no support for *= operators

	ColourRect();
	ColourRect(const Colour& col);
	ColourRect(const Colour& top_left, const Colour& top_right, const Colour& bottom_left, const Colour& bottom_right);
};



/************************************************************************
    String
*************************************************************************/
class String
{
    static const unsigned long npos;

    unsigned long size() const;
    unsigned long length() const;
    bool empty() const;
    unsigned long capacity() const;

    unsigned long& operator[] (unsigned long i);
    unsigned long& at(unsigned long i);
    string c_str() const;

    void reserve(unsigned long num=0);
    void resize(unsigned long num);
    void resize(unsigned long num, unsigned long codepoint);

    void clear();
    String& erase();
    // default len is different from usual to handle ambiguity issue
    String& erase(unsigned long idx, unsigned long len=1);

    String& replace(unsigned long begin, unsigned long len, const String&s);
    //String& replace(unsigned long begin, unsigned long len, unsigned long codepoint);

    void swap(String& s);
    String& insert(unsigned long pos, const String& s);
    //String& insert(unsigned long pos, unsigned long codepoint);

    unsigned long find(unsigned long codepoint, unsigned long idx=0) const;
    unsigned long rfind(unsigned long codepoint, unsigned long idx=-1) const;
    unsigned long find(const String& sub, unsigned long idx=0) const;
    unsigned long rfind(const String& sub, unsigned long idx=-1) const;

    String substr(unsigned long idx=0, unsigned long len=-1) const;

    void push_back(unsigned long codepoint);

    String();
    String(unsigned long num, unsigned long codepoint);
    String(utf8string s);
    String(const String& s);
};
